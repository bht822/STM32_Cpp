#ifndef _MCAL_REG_H
#define _MCAL_REG_H

#include <cstdint>
#include "mcal_reg_access.h"
#include "mcal_reg_access_dynamic.h"


namespace mcal {

	namespace reg {


					// Global base address
					const std::uint32_t periph_base     = 0x40000000U;

					// Indivisual Unit base address

					const std::uint32_t ahb1periph_base = periph_base + 0x00020000U;
					const std::uint32_t rcc_base        = ahb1periph_base + 0x00003800U;

					const std::uint32_t ahb1enr         =  rcc_base + 0x30;
					const std::uint32_t ahb2enr         =  rcc_base + 0x34;
					const std::uint32_t ahb3enr         =  rcc_base + 0x38;
					const std::uint32_t apb1enr 				=  rcc_base + 0x40;

					const std::uint32_t gpioa_base = ahb1periph_base + 0x0000;
					const std::uint32_t gpiob_base = ahb1periph_base + 0x0400;
					const std::uint32_t gpioc_base = ahb1periph_base + 0x0800;
					const std::uint32_t gpiod_base = ahb1periph_base + 0x0C00;
					const std::uint32_t gpioe_base = ahb1periph_base + 0x1000;
					const std::uint32_t gpiof_base = ahb1periph_base + 0x1400;
					const std::uint32_t gpiog_base = ahb1periph_base + 0x1800;
										
							//***Systic SCB base address 
					
					const std::uint32_t scb_base      = 0xE000E000U;
					const std::uint32_t systick_base  = scb_base + 0x010U;
					const std::uint32_t tim2_base     = periph_base ;
					const std::uint32_t tim3_base     = periph_base + 0x0400U;
					const std::uint32_t tim4_base     = periph_base + 0x0800U;
					const std::uint32_t tim5_base     = periph_base + 0x0C00U;

					
					

					//Port register

					const std::uint32_t moder_offset     = 0x0000;
					const std::uint32_t otyper_offset    = 0x0004;
					const std::uint32_t ospeedr_offset   = 0x0008;
					const std::uint32_t pupdr_offset     = 0x000C;
					const std::uint32_t idr_offset       = 0x0010;
					const std::uint32_t odr_offset       = 0x0014;
					const std::uint32_t bsrr_offset      = 0x0018;
					const std::uint32_t lckr_offset      = 0x001C;
					const std::uint32_t afrl_offset      = 0x0020;
					const std::uint32_t afrh_offset      = 0x0024;

					// GPIO A register

					const std::uint32_t gpioa_moder      = gpioa_base + moder_offset;
					const std::uint32_t gpioa_otyper     = gpioa_base + otyper_offset;
					const std::uint32_t gpioa_ospeedr    = gpioa_base + ospeedr_offset;
					const std::uint32_t gpioa_pupdr      = gpioa_base + pupdr_offset;
					const std::uint32_t gpioa_idr        = gpioa_base + idr_offset;
					const std::uint32_t gpioa_odr        = gpioa_base + odr_offset;
					const std::uint32_t gpioa_bsrr       = gpioa_base + bsrr_offset;
					const std::uint32_t gpioa_lckr       = gpioa_base + lckr_offset;
					const std::uint32_t gpioa_afrl       = gpioa_base + afrl_offset;
					const std::uint32_t gpioa_afrh       = gpioa_base + afrh_offset;

					// GPIO B register

					const std::uint32_t gpiob_moder      = gpiob_base + moder_offset;
					const std::uint32_t gpiob_otyper     = gpiob_base + otyper_offset;
					const std::uint32_t gpiob_ospeedr    = gpiob_base + ospeedr_offset;
					const std::uint32_t gpiob_pupdr      = gpiob_base + pupdr_offset;
					const std::uint32_t gpiob_idr        = gpiob_base + idr_offset;
					const std::uint32_t gpiob_odr        = gpiob_base + odr_offset;
					const std::uint32_t gpiob_bsrr       = gpiob_base + bsrr_offset;
					const std::uint32_t gpiob_lckr       = gpiob_base + lckr_offset;
					const std::uint32_t gpiob_afrl       = gpiob_base + afrl_offset;
					const std::uint32_t gpiob_afrh       = gpiob_base + afrh_offset;

					// GPIO C register

					const std::uint32_t gpioc_moder      = gpioc_base + moder_offset;
					const std::uint32_t gpioc_otyper     = gpioc_base + otyper_offset;
					const std::uint32_t gpioc_ospeedr    = gpioc_base + ospeedr_offset;
					const std::uint32_t gpioc_pupdr      = gpioc_base + pupdr_offset;
					const std::uint32_t gpioc_idr        = gpioc_base + idr_offset;
					const std::uint32_t gpioc_odr        = gpioc_base + odr_offset;
					const std::uint32_t gpioc_bsrr       = gpioc_base + bsrr_offset;
					const std::uint32_t gpioc_lckr       = gpioc_base + lckr_offset;
					const std::uint32_t gpioc_afrl       = gpioc_base + afrl_offset;
					const std::uint32_t gpioc_afrh       = gpioc_base + afrh_offset;

					// GPIO D register

					const std::uint32_t gpiod_moder      = gpiod_base + moder_offset;
					const std::uint32_t gpiod_otyper     = gpiod_base + otyper_offset;
					const std::uint32_t gpiod_ospeedr    = gpiod_base + ospeedr_offset;
					const std::uint32_t gpiod_pupdr      = gpiod_base + pupdr_offset;
					const std::uint32_t gpiod_idr        = gpiod_base + idr_offset;
					const std::uint32_t gpiod_odr        = gpiod_base + odr_offset;
					const std::uint32_t gpiod_bsrr       = gpiod_base + bsrr_offset;
					const std::uint32_t gpiod_lckr       = gpiod_base + lckr_offset;
					const std::uint32_t gpiod_afrl       = gpiod_base + afrl_offset;
					const std::uint32_t gpiod_afrh       = gpiod_base + afrh_offset;

					// GPIO E register

					const std::uint32_t gpioe_moder      = gpioe_base + moder_offset;
					const std::uint32_t gpioe_otyper     = gpioe_base + otyper_offset;
					const std::uint32_t gpioe_ospeedr    = gpioe_base + ospeedr_offset;
					const std::uint32_t gpioe_pupdr      = gpioe_base + pupdr_offset;
					const std::uint32_t gpioe_idr        = gpioe_base + idr_offset;
					const std::uint32_t gpioe_odr        = gpioe_base + odr_offset;
					const std::uint32_t gpioe_bsrr       = gpioe_base + bsrr_offset;
					const std::uint32_t gpioe_lckr       = gpioe_base + lckr_offset;
					const std::uint32_t gpioe_afrl       = gpioe_base + afrl_offset;
					const std::uint32_t gpioe_afrh       = gpioe_base + afrh_offset;

					// GPIO F register

					const std::uint32_t gpiof_moder      = gpiof_base + moder_offset;
					const std::uint32_t gpiof_otyper     = gpiof_base + otyper_offset;
					const std::uint32_t gpiof_ospeedr    = gpiof_base + ospeedr_offset;
					const std::uint32_t gpiof_pupdr      = gpiof_base + pupdr_offset;
					const std::uint32_t gpiof_idr        = gpiof_base + idr_offset;
					const std::uint32_t gpiof_odr        = gpiof_base + odr_offset;
					const std::uint32_t gpiof_bsrr       = gpiof_base + bsrr_offset;
					const std::uint32_t gpiof_lckr       = gpiof_base + lckr_offset;
					const std::uint32_t gpiof_afrl       = gpiof_base + afrl_offset;
					const std::uint32_t gpiof_afrh       = gpiof_base + afrh_offset;


					// USART base addresses 
					
					const std::uint32_t uart1_base = 0x40011000;
					const std::uint32_t uart2_base = 0x40004400;
					const std::uint32_t uart6_base = 0x40011400;
					
					
					// usart registers offset
					const std::uint32_t sr_offset   = 0x00;
					const std::uint32_t dr_offset   = 0x04;
					const std::uint32_t brr_offset  = 0x08;
					const std::uint32_t cr1_offset  = 0x0C;
					const std::uint32_t cr2_offset  = 0x10;
					const std::uint32_t cr3_offset  = 0x14;
					
					
					// USART2 registers
					
					const std::uint32_t uart2_sr  = uart2_base + sr_offset;
					const std::uint32_t uart2_dr  = uart2_base + dr_offset;
					const std::uint32_t uart2_brr = uart2_base + brr_offset;
					const std::uint32_t uart2_cr1 = uart2_base + cr1_offset;
					const std::uint32_t uart2_cr2 = uart2_base + cr2_offset;
					const std::uint32_t uart2_cr3 = uart2_base + cr3_offset;


					
					typedef struct USART_typedef{
						
						volatile std::uint32_t SR;         /* USART status register offset 0x00*/
						volatile std::uint32_t DR;         /* USART data register offset  0x04*/
						volatile std::uint32_t BRR;        /* USART baude rate register offset 0x08*/
						volatile std::uint32_t CR1;        /* USART control register 1 offset 0x0C*/
						volatile std::uint32_t CR2;        /* USART control register 2 offset 0x10*/
						volatile std::uint32_t CR3;        /* USART control register 3 offset 0x14*/
					
					
					}USART_typedef ;
					
					

					
					
					// Systic register 
					
					const std::uint32_t systick_ctrl_offset         = 0x000;
					const std::uint32_t systick_load_offset         = 0x004;
					const std::uint32_t systick_val_offset          = 0x008;
					const std::uint32_t systick_calibration_offset  = 0x00C;
					
					const std::uint32_t systick_ctrl         = systick_base + systick_ctrl_offset;
					const std::uint32_t systick_load         = systick_base + systick_load_offset;
					const std::uint32_t systick_val          = systick_base + systick_val_offset ;
					const std::uint32_t systick_calibration  = systick_base + systick_calibration_offset;
					
					
					
					typedef struct SYSTICK_typedef{
						
						volatile std::uint32_t CTRL;
						volatile std::uint32_t LOAD;
						volatile std::uint32_t VAL;
						volatile std::uint32_t CALIB;
					
					
					
					}SYSTICK_typedef;
					
					
					// Timer 2 to 5 reigister offsets

					const std::uint32_t timer_cr1_offset           = 0x00;
					const std::uint32_t timer_cr2_offset           = 0x04;
					const std::uint32_t timer_slave_mode_offset     = 0x08;
					const std::uint32_t timer_DMA_IER_offset       = 0x0C;
					const std::uint32_t timer_status_offset        = 0x10;
					const std::uint32_t timer_event_gen_offset     = 0x14;
					const std::uint32_t timer_cap_mode1_offset     = 0x18;
					const std::uint32_t	timer_cap_mode2_offset     = 0x1C;
					const std::uint32_t timer_cap_comp_en_offset   = 0x20;		
					const std::uint32_t timer_counter_offset 			 = 0x24;
					const std::uint32_t timer_prescaler_offset     = 0x28;
					const std::uint32_t timer_auto_reload_offset   = 0x2C;
					const std::uint32_t	timer_CCR1_offset          = 0x34;
					const std::uint32_t	timer_CCR2_offset          = 0x38;
					const std::uint32_t	timer_CCR3_offset          = 0x3C;
					const std::uint32_t	timer_CCR4_offset          = 0x40;
					const std::uint32_t	timer_DCR_offset           = 0x48;
					const std::uint32_t	timer_DMAR_offset          = 0x4C;
					const std::uint32_t	timer2_OR_offset           = 0x50;
					const std::uint32_t	timer5_OR_offset           = 0x50;
					
					
					// Timer 2 regsisters
					const std::uint32_t tim2_smcr    = tim2_base + timer_slave_mode_offset; 
					const std::uint32_t tim2_dier    = tim2_base + timer_DMA_IER_offset; 
					const std::uint32_t tim2_sr      = tim2_base + timer_status_offset; 
					const std::uint32_t tim2_egr     = tim2_base + timer_event_gen_offset;
					const std::uint32_t tim2_ccmr1   = tim2_base + timer_cap_mode1_offset;
					const std::uint32_t tim2_ccmr2   = tim2_base + timer_cap_mode2_offset;
					const std::uint32_t tim2_ccer    = tim2_base + timer_cap_comp_en_offset;
					const std::uint32_t tim2_psc     = tim2_base + timer_prescaler_offset; 
					const std::uint32_t tim2_arr     = tim2_base + timer_auto_reload_offset;
					const std::uint32_t tim2_cnt     = tim2_base + timer_counter_offset;
					const std::uint32_t tim2_ccr1    = tim2_base + timer_CCR1_offset;
					const std::uint32_t tim2_ccr2    = tim2_base + timer_CCR2_offset;
					const std::uint32_t tim2_ccr3    = tim2_base + timer_CCR3_offset;
					const std::uint32_t tim2_ccr4    = tim2_base + timer_CCR4_offset;


					typedef struct
					{
						volatile std::uint32_t CR1;         /*!< TIM control register 1,              Address offset: 0x00 */
						volatile std::uint32_t CR2;         /*!< TIM control register 2,              Address offset: 0x04 */
						volatile std::uint32_t SMCR;        /*!< TIM slave mode control register,     Address offset: 0x08 */
						volatile std::uint32_t DIER;        /*!< TIM DMA/interrupt enable register,   Address offset: 0x0C */
						volatile std::uint32_t SR;          /*!< TIM status register,                 Address offset: 0x10 */
						volatile std::uint32_t EGR;         /*!< TIM event generation register,       Address offset: 0x14 */
						volatile std::uint32_t CCMR1;       /*!< TIM capture/compare mode register 1, Address offset: 0x18 */
						volatile std::uint32_t CCMR2;       /*!< TIM capture/compare mode register 2, Address offset: 0x1C */
						volatile std::uint32_t CCER;        /*!< TIM capture/compare enable register, Address offset: 0x20 */
						volatile std::uint32_t CNT;         /*!< TIM counter register,                Address offset: 0x24 */
						volatile std::uint32_t PSC;         /*!< TIM prescaler,                       Address offset: 0x28 */
						volatile std::uint32_t ARR;         /*!< TIM auto-reload register,            Address offset: 0x2C */
						volatile std::uint32_t RCR;         /*!< TIM repetition counter register,     Address offset: 0x30 */
						volatile std::uint32_t CCR1;        /*!< TIM capture/compare register 1,      Address offset: 0x34 */
						volatile std::uint32_t CCR2;        /*!< TIM capture/compare register 2,      Address offset: 0x38 */
						volatile std::uint32_t CCR3;        /*!< TIM capture/compare register 3,      Address offset: 0x3C */
						volatile std::uint32_t CCR4;        /*!< TIM capture/compare register 4,      Address offset: 0x40 */
						volatile std::uint32_t BDTR;        /*!< TIM break and dead-time register,    Address offset: 0x44 */
						volatile std::uint32_t DCR;         /*!< TIM DMA control register,            Address offset: 0x48 */
						volatile std::uint32_t DMAR;        /*!< TIM DMA address for full transfer,   Address offset: 0x4C */
						volatile std::uint32_t OR;          /*!< TIM option register,                 Address offset: 0x50 */
					} TIM_TypeDef;
					
			

					
					
					






					
					
					
					
		
					
					
					
					
					
					
				
					
					
					












	}



}



#endif
